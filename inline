{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "fcddc035",
   "metadata": {},
   "outputs": [],
   "source": [
    "\"\"\"\n",
    "@inproceedings{\n",
    "    manor2024posterior,\n",
    "    title={On the Posterior Distribution in Denoising: Application to Uncertainty Quantification},\n",
    "    author={Hila Manor and Tomer Michaeli},\n",
    "    booktitle={The Twelfth International Conference on Learning Representations},\n",
    "    year={2024},\n",
    "    url={https://openreview.net/forum?id=adSGeugiuj}\n",
    "}\n",
    "\"\"\"\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "import matplotlib.patches as patches\n",
    "import os\n",
    "import subprocess # inkspace\n",
    "from scipy.linalg import toeplitz\n",
    "plt.rcParams[\"text.usetex\"] = True\n",
    "np.random.seed(100)\n",
    "# import seaborn as sns\n",
    "# sns.set_style('white')\n",
    "plt.rcParams.update({\n",
    "    \"text.usetex\": True,\n",
    "    \"font.family\": \"cmu-serif\",\n",
    "    \"mathtext.fontset\": \"cm\",\n",
    "    \"font.size\": 18\n",
    "})"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "dfec56c8",
   "metadata": {},
   "outputs": [],
   "source": [
    "def sample_multivariate_gaussian_mixture(M: int, mus: np.array, sigmas: np.array, N: int = 10000, weights: np.array = None) -> np.array:\n",
    "    \"\"\"\n",
    "    Sample data points from a Gaussian Mixture Model (GMM) using the Component Selection Method.\n",
    "    \n",
    "    This function first generates samples from all individual multivariate Gaussian distributions \n",
    "    and then selects one component per data point based on the given mixture weights.\n",
    "\n",
    "    Sampling process:\n",
    "    1. Generate an array of shape (N, d, M), where each column represents samples drawn from \n",
    "       a different Gaussian component.\n",
    "    2. Randomly select one component for each data point according to the specified `weights`.\n",
    "    3. Return the selected samples, ensuring that the final output has the shape (N, d).\n",
    "\n",
    "    Parameters:\n",
    "        M (int): Number of Gaussian components in the mixture.\n",
    "        mus (list of np.array): List of mean vectors for each Gaussian component, \n",
    "                                where each element is a (d,) numpy array.\n",
    "        sigmas (list of np.array): List of covariance matrices for each Gaussian component, \n",
    "                                   where each element is a (d, d) numpy array.\n",
    "        N (int): Number of data points to sample.\n",
    "        weights (list or np.array, optional): Probability weights for selecting each Gaussian \n",
    "                                              component. If None, all components are assumed \n",
    "                                              to be equally weighted (1/M).\n",
    "\n",
    "    Returns:\n",
    "        np.array: An array of shape (N, d), where each row is a sampled data point.\n",
    "    \"\"\"\n",
    "\n",
    "    assert (M == len(mus))\n",
    "    \n",
    "    samples = np.zeros((N, len(mus[0]), M), dtype=np.float64)\n",
    "    for i in range(M):\n",
    "        samples[:, :, i] = np.random.multivariate_normal(mus[i], sigmas[i], size=(N,)).astype(np.float64)\n",
    "\n",
    "    if weights is None:\n",
    "        weights = np.ones(M, dtype=np.float64) / M\n",
    "    random_idx = np.random.choice(np.arange(M), size=(N,), p=weights)\n",
    "    return samples[np.arange(N), :, random_idx]\n",
    "\n",
    "\n",
    "def mu1_real(y: np.array ,A: np.array, sigma1: np.array, sigma2: np.array, Nsigma: np.array, m1: np.array, m2: np.array) -> np.array:\n",
    "    \"\"\"\n",
    "    Calculates the theoretical posterior E(x|y) of a two-component GMM with transformation y = Ax + e.\n",
    "    Parameters:\n",
    "        y: np.array(d, N)         - Observations (d-dimensional, N samples)\n",
    "        sigma1: np.array(d, d)    - Covariance matrix of the first Gaussian component\n",
    "        sigma2: np.array(d, d)    - Covariance matrix of the second Gaussian component\n",
    "        Nsigma: np.array(d, d)    - Covariance matrix of noise (diagonal elements)\n",
    "        m1, m2: np.array(d, 1)    - Mean vectors of the Gaussian components\n",
    "        A: np.array(d, d)         - Transformation matrix in y = Ax + e\n",
    "    Returns:\n",
    "        E[x | y]: np.array(d, N)  - Posterior expected value of x given y\n",
    "    \"\"\"\n",
    "    y = y.astype(np.float64)\n",
    "\n",
    "    inv_term1 = np.linalg.inv(A @ sigma1 @ A.T + Nsigma)\n",
    "    inv_term2 = np.linalg.inv(A @ sigma2 @ A.T + Nsigma)\n",
    "\n",
    "    mu1 = m1 + sigma1 @ A.T @ inv_term1 @ (y - A @ m1)\n",
    "    mu2 = m2 + sigma2 @ A.T @ inv_term2 @ (y - A @ m2)\n",
    "\n",
    "    p1 = np.exp(-0.5 * np.diag((y - A @ m1).T @ inv_term1 @ (y - A @ m1)))\n",
    "    p2 = np.exp(-0.5 * np.diag((y - A @ m2).T @ inv_term2 @ (y - A @ m2)))\n",
    "\n",
    "    return (mu1 * p1 + mu2 * p2) / (p1 + p2)\n",
    "\n",
    "\n",
    "def px_pdf_real(xs, sigma1, sigma2, m1, m2):\n",
    "    # Calculate the pdf of a wo-component Gaussian Mixture Model (GMM)\n",
    "    xs = xs.astype(np.float64)\n",
    "    norm_const1 = 1 / (2* np.pi * np.linalg.det(sigma1))\n",
    "    norm_const2 = 1 / (2* np.pi * np.linalg.det(sigma2))\n",
    "    pdf1 = norm_const1 * np.diag(np.exp(-0.5 * (xs - m1).T @ np.linalg.inv((sigma1)) @ (xs - m1)))\n",
    "    pdf2 = norm_const2 * np.diag(np.exp(-0.5 * (xs - m2).T @ np.linalg.inv((sigma2)) @ (xs - m2)))\n",
    "    return 0.5 * pdf1 + 0.5 * pdf2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "7fc6913f",
   "metadata": {},
   "outputs": [],
   "source": [
    "# GMM sampling\n",
    "mus = [np.array([1, 2]), np.array([8, 10])]\n",
    "sigmas = [np.array([[1, 0], [0, 2]]), np.array([[2, 1], [1, 1]])]\n",
    "sigma1, sigma2 = sigmas\n",
    "m1, m2 = mus\n",
    "m1, m2 = m1.reshape(2,1), m2.reshape(2,1)\n",
    "x = sample_multivariate_gaussian_mixture(2, mus, sigmas, weights=np.array([0.5, 0.5])).astype(np.float64)\n",
    "x = x.T \n",
    "# Generate a random linear Transformation\n",
    "A = arr_normal = np.random.randn(2, 2)\n",
    "print(np.linalg.det(A) == 0) # check the singularity of A\n",
    "\n",
    "# Generagte noise\n",
    "\n",
    "noise_sigma2 = 2\n",
    "Nsigma = noise_sigma2 * np.eye(2)\n",
    "n = np.random.multivariate_normal(np.array([0, 0]), Nsigma, (len(x.T),)).astype(np.float64).T\n",
    "\n",
    "# create y\n",
    "y = A @ x + n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "7bfbc084",
   "metadata": {},
   "outputs": [],
   "source": [
    "def compute_snr(A, x, n):\n",
    "    \"\"\"\n",
    "    Compute Signal-to-Noise Ratio (SNR)\n",
    "    params: \n",
    "        A: Transformation matrix (2,2)\n",
    "        x: Original signal (2, N)\n",
    "        n: Noise (2, N)\n",
    "    Returns:\n",
    "        SNR (dB)\n",
    "    \"\"\"\n",
    "    Ax = A @ x  # Transformed signal\n",
    "    signal_power = np.mean(np.linalg.norm(Ax, axis=0) ** 2)  # Compute signal power\n",
    "    noise_power = np.mean(np.linalg.norm(n, axis=0) ** 2)  # Compute noise power\n",
    "    snr_db = 10 * np.log10(signal_power / noise_power)  # Convert to dB\n",
    "    return snr_db\n",
    "\n",
    "snr_value = compute_snr(A, x, n)\n",
    "print(f\"SNR (dB): {snr_value:.2f}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "68889f9a",
   "metadata": {},
   "outputs": [],
   "source": [
    "train_samples_x = x[:, :int(x.shape[-1] * 0.8)]\n",
    "test_samples_x  = x[:, int(x.shape[-1] * 0.8):]\n",
    "train_samples_y = y[:, :int(y.shape[-1] * 0.8)]\n",
    "test_samples_y  = y[:, int(y.shape[-1] * 0.8):]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "a0e5e230",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "%matplotlib inline\n",
    "mu1_real_res = mu1_real(test_samples_y, A, sigma1, sigma2, Nsigma, m1, m2)\n",
    "\n",
    "plt.figure(figsize=(15,5))\n",
    "plt.subplot(1, 3, 1)\n",
    "plt.scatter(test_samples_y[0], test_samples_y[1], marker='.', color='red', alpha=1, label='y')\n",
    "# sns.scatterplot(test_samples_y, marker='.', color='red', alpha=1, label='y')\n",
    "plt.scatter(test_samples_x[0], test_samples_x[1], marker='.', color='green', alpha=0.7, label='x')\n",
    "plt.legend(loc='lower right', fontsize=12)\n",
    "plt.title('$p(x)$ vs $p(y)$', fontsize=14)\n",
    "\n",
    "plt.subplot(1, 3, 2)\n",
    "plt.scatter(test_samples_y[0], test_samples_y[1], marker='.', color='red', alpha=1, label='y')\n",
    "plt.scatter(mu1_real_res[0], mu1_real_res[1], marker='.', color='blue', alpha=0.7, label='x$|$y')\n",
    "plt.legend(loc='lower right', fontsize=12)\n",
    "plt.title('$p(y)$ vs $p(x|y)$', fontsize=14)\n",
    "\n",
    "plt.subplot(1, 3, 3)\n",
    "plt.scatter(test_samples_x[0], test_samples_x[1], marker='.', color='green', alpha=1, label='x')\n",
    "plt.scatter(mu1_real_res[0], mu1_real_res[1], marker='.', color='blue', alpha=0.7, label='x$|$y')\n",
    "plt.legend(loc='lower right', fontsize=12)\n",
    "plt.title('$p(x)$ vs $p(x|y)$', fontsize=14)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "482a3767",
   "metadata": {},
   "outputs": [],
   "source": [
    "x_1 = np.array([4.5, 5]).reshape(2,1).astype(np.float64)\n",
    "y_1 = A @ x_1 + np.random.multivariate_normal(np.array([0,0]), Nsigma, (1,)).reshape(2,1).astype(np.float64)\n",
    "# y_1 = np.array([[3.5], [6.35]]).astype(np.float64)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "4cfb08e0",
   "metadata": {},
   "outputs": [],
   "source": [
    "iters = 500\n",
    "n_ev = 2\n",
    "c = 1e-5\n",
    "\n",
    "custom_ev = None\n",
    "\n",
    "A_invT = np.linalg.inv(A.T)\n",
    "mmse = mu1_real(y_1, A, sigma1, sigma2, Nsigma, m1, m2)\n",
    "bmmse = np.concatenate([mmse] * n_ev, axis=1)\n",
    "eigvecs = np.random.randn(*bmmse.shape).astype(np.float64)\n",
    "if custom_ev is None:\n",
    "    for i in range(iters):\n",
    "        out = mu1_real(y_1 + eigvecs, A, sigma1, sigma2, Nsigma, m1, m2)\n",
    "        Ab = (out - mmse)\n",
    "        Ab = Ab @ A_invT\n",
    "        if n_ev > 1:\n",
    "            norm_of_Ab = np.linalg.norm(Ab.astype(np.float64), axis=0).astype(np.float64)\n",
    "            eigvecs = Ab / norm_of_Ab  # Complete the power iteration\n",
    "            \n",
    "            # Make sure the evs are orthonormal\n",
    "            Q = np.linalg.qr(eigvecs.astype(np.float64), mode='reduced')[0].astype(np.float64)\n",
    "            eigvecs = Q / np.linalg.norm(Q.astype(np.float64), axis=0).astype(np.float64)\n",
    "        else:\n",
    "            norm_of_Ab = np.linalg.norm(Ab.astype(np.float64).ravel()).astype(np.float64)\n",
    "            eigvecs = Ab / norm_of_Ab # This completes the power iteration\n",
    "        eigvecs *= c\n",
    "    eigvals = (norm_of_Ab / c * noise_sigma2).reshape(n_ev, )\n",
    "    eigvals /= np.linalg.norm(A_invT, ord=2)\n",
    "    eigvecs /= c\n",
    "else:\n",
    "    eigvecs = custom_ev\n",
    "    out = mu1_real(y_1 + eigvecs * c, A, sigma1, sigma2, Nsigma, m1, m2)\n",
    "    Ab = (out - mmse)\n",
    "    Ab = Ab @ A_invT\n",
    "    eigvals = np.linalg.norm(Ab.astype(np.float64), axis=0).astype(np.float64) / c * noise_sigma2\n",
    "    eigvals /= np.linalg.norm(A_invT, ord=2)\n",
    "first_moments = eigvecs.T @ mmse\n",
    "second_moments = eigvals"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "ba6c1003",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "plt.figure(figsize=(6,5))\n",
    "# plt.scatter(test_samples_y[0], test_samples_y[1], marker='.', color='#fe94d0', alpha=0.6, label='samples from $p_y$', s=5)\n",
    "# plt.scatter(test_samples_x[0], test_samples_x[1], marker='.', color='#74add1', alpha=1, label='samples from $p_x$', s=5)\n",
    "[XX, YY] = np.meshgrid(np.linspace(-4,13, 100), np.linspace(-4,13, 100))\n",
    "xs = np.stack([XX.ravel(), YY.ravel()])\n",
    "\n",
    "c = plt.imshow(px_pdf_real(xs, sigma1, sigma2, m1, m2).reshape(XX.shape), cmap='Blues', origin='lower', extent=[-4, 13, -4, 13], interpolation='bilinear')\n",
    "\n",
    "angle = np.arctan2(eigvecs[1,0], eigvecs[0,0]) * 180 / np.pi\n",
    "ellipse = patches.Ellipse((mmse[0,0], mmse[1,0]), 2 * np.sqrt(eigvals[0]), 2 * np.sqrt(eigvals[1]), angle=angle,\n",
    "                          fill=False, alpha=0.7, edgecolor='#053061', label='$\\sqrt{\\lambda}$')\n",
    "plt.gca().add_artist(ellipse)\n",
    "\n",
    "threesig_ellipse = patches.Ellipse((mmse[0,0], mmse[1,0]), 6 * np.sqrt(eigvals[0]), 6 * np.sqrt(eigvals[1]), angle=angle,\n",
    "                          fill=False, alpha=0.7, edgecolor='#053061', linestyle='--', label='$3\\sqrt{\\lambda}$')\n",
    "plt.gca().add_artist(threesig_ellipse)\n",
    "\n",
    "plt.arrow(mmse[0,0], mmse[1,0], eigvecs[0,0] * 3 * np.sqrt(eigvals[0]), eigvecs[1,0] * 3 * np.sqrt(eigvals[0]), head_length=0, color='#d6604d', linewidth=2, label='$v_1$')\n",
    "plt.arrow(mmse[0,0], mmse[1,0], -eigvecs[0,0] * 3 * np.sqrt(eigvals[0]), -eigvecs[1,0] * 3 * np.sqrt(eigvals[0]), head_length=0, color='#d6604d', linewidth=2)\n",
    "if n_ev > 1:\n",
    "    plt.arrow(mmse[0,0], mmse[1,0], eigvecs[0,1] * 3 * np.sqrt(eigvals[1]), eigvecs[1,1] * 3 * np.sqrt(eigvals[1]), head_length=0, color='#f7b068', linewidth=2, label='$v_2$')\n",
    "    plt.arrow(mmse[0,0], mmse[1,0], -eigvecs[0,1] * 3 * np.sqrt(eigvals[1]), -eigvecs[1,1] * 3 * np.sqrt(eigvals[1]), head_length=0, color='#f7b068', linewidth=2)\n",
    "plt.scatter(y_1[0], y_1[1], marker='o', color='red', label='$y$', s=70)\n",
    "plt.scatter(mmse[0], mmse[1], marker='o', color='black', label='$\\mu_1(y)$', s=70)\n",
    "\n",
    "y_up = (mmse + 3 * np.sqrt(eigvals) * eigvecs)[:,0]\n",
    "y_down = (mmse - 3 * np.sqrt(eigvals) * eigvecs)[:, 0]\n",
    "\n",
    "# plt.scatter(y_up[0], y_up[1], marker='+', color='black', label='$\\mu_1(y) +3\\sqrt{\\lambda} v$', s=70)\n",
    "# plt.scatter(y_down[0], y_down[1], marker='*', color='black', label='$\\mu_1(y) -3 \\sqrt{\\lambda} v$', s=70)\n",
    "# plt.gca().axis([test_samples_y.min(), test_samples_y.max(), test_samples_y.min(), test_samples_y.max()])\n",
    "plt.colorbar(c, ax=plt.gca(), label=\"$p_x$\", fraction=0.046, pad=0.04)\n",
    "\n",
    "# plt.colorbar()\n",
    "# plt.clabel('$p_x$')\n",
    "plt.legend(loc='lower right', labelspacing=0.3)\n",
    "plt.tight_layout()\n",
    "ylimmin, ylimmax = plt.gca().get_ylim()\n",
    "xlimmin, xlimmax = plt.gca().get_xlim()\n",
    "os.makedirs('Figures', exist_ok=True)\n",
    "plt.savefig(os.path.join('Figures', 'GMM_Example_theoretical.pdf'), dpi=500, bbox_inches='tight')\n",
    "plt.savefig(os.path.join('Figures', 'GMM_Example_theoretical.png'), dpi=500, bbox_inches='tight')\n",
    "plt.savefig(os.path.join('Figures', 'GMM_Example_theoretical.svg'), dpi=500, bbox_inches='tight')\n",
    "plt.savefig(os.path.join('Figures', 'GMM_Example_theoretical.eps'), dpi=500, bbox_inches='tight')\n",
    "subprocess.call('inkscape Figures/GMM_Example_theoretical.svg --export-type=\"emf\"',shell=True)\n",
    "\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "d0a020d9",
   "metadata": {},
   "outputs": [],
   "source": [
    "h=1e-5\n",
    "third_moments = []\n",
    "fourth_moments = []\n",
    "for i in range(n_ev):\n",
    "    first_term = mu1_real(y_1 + eigvecs[:, i].reshape(2,1) * 2 * h, A, sigma1, sigma2, Nsigma, m1, m2)\n",
    "    second_term = mu1_real(y_1 + eigvecs[:, i].reshape(2,1) * h, A, sigma1, sigma2, Nsigma, m1, m2)\n",
    "    third_term = mu1_real(y_1, A, sigma1, sigma2, Nsigma, m1, m2)\n",
    "    fourth_term = mu1_real(y_1 - eigvecs[:, i].reshape(2,1) * h, A, sigma1, sigma2, Nsigma, m1, m2)\n",
    "    deriv_approx = (1/(h**3)) * (first_term - 3 * second_term + 3 * third_term - fourth_term)\n",
    "\n",
    "    fourth_moments.append((noise_sigma2 ** 3) * (eigvecs[:, i] @ deriv_approx)[0] + 3 * (second_moments[i] ** 2))\n",
    "\n",
    "    deriv_approx = (1/(h**2)) * (second_term - 2 * third_term + fourth_term)\n",
    "    third_moments.append((noise_sigma2 ** 2) * (eigvecs[:, i] @ deriv_approx)[0])\n",
    "\n",
    "print(f'vmu1 = {first_moments[:,0]};')\n",
    "print(f'vmu2 = {second_moments};')\n",
    "print(f'vmu3 = {third_moments};')\n",
    "print(f'vmu4 = {fourth_moments};')\n",
    "print(f'noisy_sample = [{y_1[0,0]}; {y_1[1,0]}];')\n",
    "print(f'mmse_sample = [{mmse[0,0]}; {mmse[1,0]}];')\n",
    "print(f'real_sample = [{x_1[0,0]} {x_1[1,0]}];')\n",
    "print(f'evs = {eigvecs};')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "1187de5b",
   "metadata": {},
   "outputs": [],
   "source": [
    "# x: sqrt(second_moments), i.e. lambda/eigenvalues of the second moment matrix\n",
    "# y: v^T E(x|y)\n",
    "%notebook inline\n",
    "\n",
    "def poly(xs, coeffs):\n",
    "    deg = len(coeffs) -1\n",
    "    \n",
    "    value = np.zeros_like(xs, dtype=xs.dtype)\n",
    "    for d in range(len(coeffs)):\n",
    "        value += coeffs[d] * (xs ** (deg - d))\n",
    "    return value\n",
    "\n",
    "def d1_dx_poly(xs, coeffs):\n",
    "    deg = len(coeffs) - 1\n",
    "    \n",
    "    value = np.zeros_like(xs, dtype=xs.dtype)\n",
    "    for i in range(deg):\n",
    "        value += (deg - i) * coeffs[i] * (xs ** (deg - 1 - i))\n",
    "    return value\n",
    "\n",
    "def d2_dx_poly(xs, coeffs):\n",
    "    deg = len(coeffs) - 1\n",
    "    \n",
    "    value = np.zeros_like(xs, dtype=xs.dtype)\n",
    "    for i in range(deg - 1):\n",
    "        value += (deg - i) * (deg - 1 - i) * coeffs[i] * (xs ** (deg - 2 - i))\n",
    "    return value\n",
    "    \n",
    "def d3_dx_poly(xs, coeffs):\n",
    "    deg = len(coeffs) - 1\n",
    "    \n",
    "    value = np.zeros_like(xs, dtype=xs.dtype)\n",
    "    for i in range(deg - 2):\n",
    "        value += (deg - i) * (deg - 1 - i) * (deg - 2 - i) * coeffs[i] * (xs ** (deg - 3 - i))\n",
    "    return value\n",
    "\n",
    "\n",
    "deg = 6\n",
    "delta = 30\n",
    "fromto = 0.5\n",
    "third_moments = []\n",
    "fourth_moments = []\n",
    "plt.figure(figsize=(7*n_ev, 4))\n",
    "for i in range(n_ev):\n",
    "    poly_xs = np.linspace(-fromto, fromto,delta) * np.sqrt(second_moments[i])\n",
    "    poly_ys = eigvecs[:, i] @ mu1_real(y_1 + poly_xs * eigvecs[:, i].reshape(2,1),  A, sigma1, sigma2, Nsigma, m1, m2)\n",
    "\n",
    "    coeffs = np.polyfit(poly_xs.astype(np.float64), poly_ys.astype(np.float64), deg=deg)\n",
    "\n",
    "    plt.subplot(1, n_ev, i + 1)\n",
    "    plt.plot(np.linspace(-fromto, fromto,delta), poly_ys, 'k.')\n",
    "    poly_more_xs = np.linspace(-fromto, fromto, delta * 10) * np.sqrt(second_moments[i])\n",
    "    \n",
    "    realf = eigvecs[:, i] @ mu1_real(y_1 + poly_more_xs * eigvecs[:, i].reshape(2,1),  A, sigma1, sigma2, Nsigma, m1, m2)\n",
    "    plt.plot(np.linspace(-fromto, fromto,delta*10), realf, label=\"real\")\n",
    "    plt.plot(np.linspace(-fromto, fromto,delta*10), poly(poly_more_xs, coeffs), label=\"poly\")\n",
    "    plt.legend()\n",
    "    plt.title(f'ev {i+1}')\n",
    "    \n",
    "    d1_dx = noise_sigma2 * d1_dx_poly(np.array([0], dtype=y_1.dtype), coeffs)\n",
    "    print(f'd1_x[0]: {d1_dx[0]}')\n",
    "    d2_dx = d2_dx_poly(np.array([0], dtype=y_1.dtype), coeffs)\n",
    "    d3_dx = d3_dx_poly(np.array([0], dtype=y_1.dtype), coeffs)\n",
    "    third_moments.append((noise_sigma2 ** 2) * (d2_dx)[0])\n",
    "    # fourth_moments.append((noise_sigma2 ** 3) * d3_dx[0] + 3 * (second_moments[i] ** 2))\n",
    "    fourth_moments.append((noise_sigma2 ** 3) * d3_dx[0] + 3 * (d1_dx[0] ** 2))\n",
    "\n",
    "plt.suptitle(f'deg={deg} $N_{{pts}}$={delta}')\n",
    "#     first_term = mu1_real(y_1 + eigvecs[:, i].reshape(2,1) * 2 * h, sigma1, sigma2, Nsigma, m1, m2)\n",
    "#     second_term = mu1_real(y_1 + eigvecs[:, i].reshape(2,1) * h, sigma1, sigma2, Nsigma, m1, m2)\n",
    "#     third_term = mu1_real(y_1, sigma1, sigma2, Nsigma, m1, m2)\n",
    "#     fourth_term = mu1_real(y_1 - eigvecs[:, i].reshape(2,1) * h, sigma1, sigma2, Nsigma, m1, m2)\n",
    "#     deriv_approx = (1/(h**3)) * (first_term - 3 * second_term + 3 * third_term - fourth_term)\n",
    "\n",
    "#     fourth_moments.append((noise_sigma2 ** 3) * (eigvecs[:, i] @ deriv_approx)[0] + 3 * (second_moments[i] ** 2))\n",
    "\n",
    "#     deriv_approx = (1/(h**2)) * (second_term - 2 * third_term + fourth_term)\n",
    "#     third_moments.append((noise_sigma2 ** 2) * (eigvecs[:, i] @ deriv_approx)[0])\n",
    "\n",
    "print(f'vmu1 = {first_moments[:,0]};')\n",
    "print(f'vmu2 = {second_moments};')\n",
    "print(f'vmu3 = {third_moments};')\n",
    "print(f'vmu4 = {fourth_moments};')\n",
    "print(f'noisy_sample = [{y_1[0,0]}; {y_1[1,0]}];')\n",
    "print(f'mmse_sample = [{mmse[0,0]}; {mmse[1,0]}];')\n",
    "print(f'real_sample = [{x_1[0,0]} {x_1[1,0]}];')\n",
    "print(f'evs = {eigvecs};')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "021d8237",
   "metadata": {},
   "outputs": [],
   "source": [
    "%notebook inline\n",
    "\n",
    "def poly(xs, coeffs):\n",
    "    deg = len(coeffs) -1\n",
    "    \n",
    "    value = np.zeros_like(xs, dtype=xs.dtype)\n",
    "    for d in range(len(coeffs)):\n",
    "        value += coeffs[d] * (xs ** (deg - d))\n",
    "    return value\n",
    "\n",
    "def d1_dx_poly(xs, coeffs):\n",
    "    deg = len(coeffs) - 1\n",
    "    \n",
    "    value = np.zeros_like(xs, dtype=xs.dtype)\n",
    "    for i in range(deg):\n",
    "        value += (deg - i) * coeffs[i] * (xs ** (deg - 1 - i))\n",
    "    return value\n",
    "\n",
    "def d2_dx_poly(xs, coeffs):\n",
    "    deg = len(coeffs) - 1\n",
    "    \n",
    "    value = np.zeros_like(xs, dtype=xs.dtype)\n",
    "    for i in range(deg - 1):\n",
    "        value += (deg - i) * (deg - 1 - i) * coeffs[i] * (xs ** (deg - 2 - i))\n",
    "    return value\n",
    "    \n",
    "def d3_dx_poly(xs, coeffs):\n",
    "    deg = len(coeffs) - 1\n",
    "    \n",
    "    value = np.zeros_like(xs, dtype=xs.dtype)\n",
    "    for i in range(deg - 2):\n",
    "        value += (deg - i) * (deg - 1 - i) * (deg - 2 - i) * coeffs[i] * (xs ** (deg - 3 - i))\n",
    "    return value\n",
    "\n",
    "\n",
    "deg = 6\n",
    "delta = 30\n",
    "fromto = 1\n",
    "\n",
    "h=1e-4\n",
    "third_moments = []\n",
    "fourth_moments = []\n",
    "plt.figure(figsize=(7*n_ev, 4))\n",
    "for i in range(n_ev):\n",
    "    poly_xs = np.linspace(-fromto, fromto,delta) * np.sqrt(second_moments[i])\n",
    "    poly_ys = eigvecs[:, i] @ mu1_real(y_1 + poly_xs * eigvecs[:, i].reshape(2,1), A, sigma1, sigma2, Nsigma, m1, m2)\n",
    "\n",
    "    coeffs = np.polyfit(poly_xs.astype(np.float64), poly_ys.astype(np.float64), deg=deg)\n",
    "\n",
    "    plt.subplot(2, n_ev, 2*i + 1)\n",
    "    plt.plot(np.linspace(-fromto, fromto,delta), poly_ys, 'k.')\n",
    "    poly_more_xs = np.linspace(-fromto, fromto, delta * 10) * np.sqrt(second_moments[i])\n",
    "    \n",
    "    realf = eigvecs[:, i] @ mu1_real(y_1 + poly_more_xs * eigvecs[:, i].reshape(2,1), A, sigma1, sigma2, Nsigma, m1, m2)\n",
    "    plt.plot(np.linspace(-fromto, fromto,delta*10), realf, label=\"real\")\n",
    "    plt.plot(np.linspace(-fromto, fromto,delta*10), poly(poly_more_xs, coeffs), label=\"poly\")\n",
    "    plt.legend()\n",
    "    plt.title(f'ev {i+1}')\n",
    "\n",
    "    plt.subplot(2, n_ev, 2*i + 2)\n",
    "    graph_len = len(np.linspace(-fromto, fromto,delta)) //5 * 2\n",
    "    plt.plot(np.linspace(-fromto, fromto,delta)[graph_len:-graph_len], poly_ys[graph_len:-graph_len], 'k.')\n",
    "    graph_len = len(np.linspace(-fromto, fromto,delta*10)) // 8 *3\n",
    "    plt.plot(np.linspace(-fromto, fromto,delta*10)[graph_len:-graph_len], realf[graph_len:-graph_len], label=\"real\")\n",
    "    plt.plot(np.linspace(-fromto, fromto,delta*10)[graph_len:-graph_len], poly(poly_more_xs, coeffs)[graph_len:-graph_len], label=\"poly\")\n",
    "    plt.legend()\n",
    "\n",
    "    first_term = poly(np.array([2 * h], dtype=y_1.dtype)* np.sqrt(second_moments[i]), coeffs)\n",
    "    second_term = poly(np.array([h], dtype=y_1.dtype)* np.sqrt(second_moments[i]), coeffs)\n",
    "    third_term = poly(np.array([0], dtype=y_1.dtype), coeffs)\n",
    "    fourth_term = poly(np.array([- h], dtype=y_1.dtype)* np.sqrt(second_moments[i]), coeffs)\n",
    "    deriv_approx = (1/(h**3)) * (first_term - 3 * second_term + 3 * third_term - fourth_term)\n",
    "\n",
    "    fourth_moments.append((noise_sigma2 ** 3) * (deriv_approx[0]) + 3 * (second_moments[i] ** 2))\n",
    "\n",
    "    deriv_approx = (1/(h**2)) * (second_term - 2 * third_term + fourth_term)\n",
    "    third_moments.append((noise_sigma2 ** 2) * (deriv_approx[0]))\n",
    "\n",
    "\n",
    "\n",
    "plt.suptitle(f'deg={deg} $N_{{pts}}$={delta}')\n",
    "#     first_term = mu1_real(y_1 + eigvecs[:, i].reshape(2,1) * 2 * h, sigma1, sigma2, Nsigma, m1, m2)\n",
    "#     second_term = mu1_real(y_1 + eigvecs[:, i].reshape(2,1) * h, sigma1, sigma2, Nsigma, m1, m2)\n",
    "#     third_term = mu1_real(y_1, sigma1, sigma2, Nsigma, m1, m2)\n",
    "#     fourth_term = mu1_real(y_1 - eigvecs[:, i].reshape(2,1) * h, sigma1, sigma2, Nsigma, m1, m2)\n",
    "#     deriv_approx = (1/(h**3)) * (first_term - 3 * second_term + 3 * third_term - fourth_term)\n",
    "\n",
    "#     fourth_moments.append((noise_sigma2 ** 3) * (eigvecs[:, i] @ deriv_approx)[0] + 3 * (second_moments[i] ** 2))\n",
    "\n",
    "#     deriv_approx = (1/(h**2)) * (second_term - 2 * third_term + fourth_term)\n",
    "#     third_moments.append((noise_sigma2 ** 2) * (eigvecs[:, i] @ deriv_approx)[0])\n",
    "\n",
    "print(f'vmu1 = {first_moments[:,0]};')\n",
    "print(f'vmu2 = {second_moments};')\n",
    "print(f'vmu3 = {third_moments};')\n",
    "print(f'vmu4 = {fourth_moments};')\n",
    "print(f'noisy_sample = [{y_1[0,0]}; {y_1[1,0]}];')\n",
    "print(f'mmse_sample = [{mmse[0,0]}; {mmse[1,0]}];')\n",
    "print(f'real_sample = [{x_1[0,0]} {x_1[1,0]}];')\n",
    "print(f'evs = {eigvecs};')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "611bef83",
   "metadata": {},
   "outputs": [],
   "source": [
    "\"\"\"\n",
    "@inproceedings{\n",
    "    manor2024posterior,\n",
    "    title={On the Posterior Distribution in Denoising: Application to Uncertainty Quantification},\n",
    "    author={Hila Manor and Tomer Michaeli},\n",
    "    booktitle={The Twelfth International Conference on Learning Representations},\n",
    "    year={2024},\n",
    "    url={https://openreview.net/forum?id=adSGeugiuj}\n",
    "}\n",
    "\"\"\"\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "import matplotlib.patches as patches\n",
    "import os\n",
    "import subprocess # inkspace\n",
    "from scipy.linalg import toeplitz\n",
    "plt.rcParams[\"text.usetex\"] = True\n",
    "np.random.seed(20)\n",
    "# import seaborn as sns\n",
    "# sns.set_style('white')\n",
    "plt.rcParams.update({\n",
    "    \"text.usetex\": True,\n",
    "    \"font.family\": \"cmu-serif\",\n",
    "    \"mathtext.fontset\": \"cm\",\n",
    "    \"font.size\": 18\n",
    "})"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "ce681619",
   "metadata": {},
   "outputs": [],
   "source": [
    "def sample_multivariate_gaussian_mixture(M: int, mus: np.array, sigmas: np.array, N: int = 10000, weights: np.array = None) -> np.array:\n",
    "    \"\"\"\n",
    "    Sample data points from a Gaussian Mixture Model (GMM) using the Component Selection Method.\n",
    "    \n",
    "    This function first generates samples from all individual multivariate Gaussian distributions \n",
    "    and then selects one component per data point based on the given mixture weights.\n",
    "\n",
    "    Sampling process:\n",
    "    1. Generate an array of shape (N, d, M), where each column represents samples drawn from \n",
    "       a different Gaussian component.\n",
    "    2. Randomly select one component for each data point according to the specified `weights`.\n",
    "    3. Return the selected samples, ensuring that the final output has the shape (N, d).\n",
    "\n",
    "    Parameters:\n",
    "        M (int): Number of Gaussian components in the mixture.\n",
    "        mus (list of np.array): List of mean vectors for each Gaussian component, \n",
    "                                where each element is a (d,) numpy array.\n",
    "        sigmas (list of np.array): List of covariance matrices for each Gaussian component, \n",
    "                                   where each element is a (d, d) numpy array.\n",
    "        N (int): Number of data points to sample.\n",
    "        weights (list or np.array, optional): Probability weights for selecting each Gaussian \n",
    "                                              component. If None, all components are assumed \n",
    "                                              to be equally weighted (1/M).\n",
    "\n",
    "    Returns:\n",
    "        np.array: An array of shape (N, d), where each row is a sampled data point.\n",
    "    \"\"\"\n",
    "\n",
    "    assert (M == len(mus))\n",
    "    \n",
    "    samples = np.zeros((N, len(mus[0]), M), dtype=np.float64)\n",
    "    for i in range(M):\n",
    "        samples[:, :, i] = np.random.multivariate_normal(mus[i], sigmas[i], size=(N,)).astype(np.float64)\n",
    "\n",
    "    if weights is None:\n",
    "        weights = np.ones(M, dtype=np.float64) / M\n",
    "    random_idx = np.random.choice(np.arange(M), size=(N,), p=weights)\n",
    "    return samples[np.arange(N), :, random_idx]\n",
    "\n",
    "\n",
    "def mu1_real(y: np.array ,A: np.array, sigma1: np.array, sigma2: np.array, Nsigma: np.array, m1: np.array, m2: np.array) -> np.array:\n",
    "    \"\"\"\n",
    "    Calculates the theoretical posterior E(x|y) of a two-component GMM with transformation y = Ax + e.\n",
    "    Parameters:\n",
    "        y: np.array(d, N)         - Observations (d-dimensional, N samples)\n",
    "        sigma1: np.array(d, d)    - Covariance matrix of the first Gaussian component\n",
    "        sigma2: np.array(d, d)    - Covariance matrix of the second Gaussian component\n",
    "        Nsigma: np.array(d, d)    - Covariance matrix of noise (diagonal elements)\n",
    "        m1, m2: np.array(d, 1)    - Mean vectors of the Gaussian components\n",
    "        A: np.array(d, d)         - Transformation matrix in y = Ax + e\n",
    "    Returns:\n",
    "        E[x | y]: np.array(d, N)  - Posterior expected value of x given y\n",
    "    \"\"\"\n",
    "    y = y.astype(np.float64)\n",
    "\n",
    "    inv_term1 = np.linalg.inv(A @ sigma1 @ A.T + Nsigma)\n",
    "    inv_term2 = np.linalg.inv(A @ sigma2 @ A.T + Nsigma)\n",
    "\n",
    "    mu1 = m1 + sigma1 @ A.T @ inv_term1 @ (y - A @ m1)\n",
    "    mu2 = m2 + sigma2 @ A.T @ inv_term2 @ (y - A @ m2)\n",
    "\n",
    "    p1 = np.exp(-0.5 * np.diag((y - A @ m1).T @ inv_term1 @ (y - A @ m1)))\n",
    "    p2 = np.exp(-0.5 * np.diag((y - A @ m2).T @ inv_term2 @ (y - A @ m2)))\n",
    "\n",
    "    return (mu1 * p1 + mu2 * p2) / (p1 + p2)\n",
    "\n",
    "\n",
    "def px_pdf_real(xs, sigma1, sigma2, m1, m2):\n",
    "    # Calculate the pdf of a wo-component Gaussian Mixture Model (GMM)\n",
    "    xs = xs.astype(np.float64)\n",
    "    norm_const1 = 1 / (2* np.pi * np.linalg.det(sigma1))\n",
    "    norm_const2 = 1 / (2* np.pi * np.linalg.det(sigma2))\n",
    "    pdf1 = norm_const1 * np.diag(np.exp(-0.5 * (xs - m1).T @ np.linalg.inv((sigma1)) @ (xs - m1)))\n",
    "    pdf2 = norm_const2 * np.diag(np.exp(-0.5 * (xs - m2).T @ np.linalg.inv((sigma2)) @ (xs - m2)))\n",
    "    return 0.5 * pdf1 + 0.5 * pdf2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "2c9b92ef",
   "metadata": {},
   "outputs": [],
   "source": [
    "# GMM sampling\n",
    "mus = [np.array([1, 2]), np.array([8, 10])]\n",
    "sigmas = [np.array([[1, 0], [0, 2]]), np.array([[2, 1], [1, 1]])]\n",
    "sigma1, sigma2 = sigmas\n",
    "m1, m2 = mus\n",
    "m1, m2 = m1.reshape(2,1), m2.reshape(2,1)\n",
    "x = sample_multivariate_gaussian_mixture(2, mus, sigmas, weights=np.array([0.5, 0.5])).astype(np.float64)\n",
    "x = x.T \n",
    "# Generate a random linear Transformation\n",
    "A = arr_normal = np.random.randn(2, 2)\n",
    "print(np.linalg.det(A) == 0) # check the singularity of A\n",
    "\n",
    "# Generagte noise\n",
    "\n",
    "noise_sigma2 = 2\n",
    "Nsigma = noise_sigma2 * np.eye(2)\n",
    "n = np.random.multivariate_normal(np.array([0, 0]), Nsigma, (len(x.T),)).astype(np.float64).T\n",
    "\n",
    "# create y\n",
    "y = A @ x + n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "33f961cc",
   "metadata": {},
   "outputs": [],
   "source": [
    "def compute_snr(A, x, n):\n",
    "    \"\"\"\n",
    "    Compute Signal-to-Noise Ratio (SNR)\n",
    "    params: \n",
    "        A: Transformation matrix (2,2)\n",
    "        x: Original signal (2, N)\n",
    "        n: Noise (2, N)\n",
    "    Returns:\n",
    "        SNR (dB)\n",
    "    \"\"\"\n",
    "    Ax = A @ x  # Transformed signal\n",
    "    signal_power = np.mean(np.linalg.norm(Ax, axis=0) ** 2)  # Compute signal power\n",
    "    noise_power = np.mean(np.linalg.norm(n, axis=0) ** 2)  # Compute noise power\n",
    "    snr_db = 10 * np.log10(signal_power / noise_power)  # Convert to dB\n",
    "    return snr_db\n",
    "\n",
    "snr_value = compute_snr(A, x, n)\n",
    "print(f\"SNR (dB): {snr_value:.2f}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "a98aad87",
   "metadata": {},
   "outputs": [],
   "source": [
    "train_samples_x = x[:, :int(x.shape[-1] * 0.8)]\n",
    "test_samples_x  = x[:, int(x.shape[-1] * 0.8):]\n",
    "train_samples_y = y[:, :int(y.shape[-1] * 0.8)]\n",
    "test_samples_y  = y[:, int(y.shape[-1] * 0.8):]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "2d96a967",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "%matplotlib inline\n",
    "mu1_real_res = mu1_real(test_samples_y, A, sigma1, sigma2, Nsigma, m1, m2)\n",
    "\n",
    "plt.figure(figsize=(15,5))\n",
    "plt.subplot(1, 3, 1)\n",
    "plt.scatter(test_samples_y[0], test_samples_y[1], marker='.', color='red', alpha=1, label='y')\n",
    "# sns.scatterplot(test_samples_y, marker='.', color='red', alpha=1, label='y')\n",
    "plt.scatter(test_samples_x[0], test_samples_x[1], marker='.', color='green', alpha=0.7, label='x')\n",
    "plt.legend(loc='lower right', fontsize=12)\n",
    "plt.title('$p(x)$ vs $p(y)$', fontsize=14)\n",
    "\n",
    "plt.subplot(1, 3, 2)\n",
    "plt.scatter(test_samples_y[0], test_samples_y[1], marker='.', color='red', alpha=1, label='y')\n",
    "plt.scatter(mu1_real_res[0], mu1_real_res[1], marker='.', color='blue', alpha=0.7, label='x$|$y')\n",
    "plt.legend(loc='lower right', fontsize=12)\n",
    "plt.title('$p(y)$ vs $p(x|y)$', fontsize=14)\n",
    "\n",
    "plt.subplot(1, 3, 3)\n",
    "plt.scatter(test_samples_x[0], test_samples_x[1], marker='.', color='green', alpha=1, label='x')\n",
    "plt.scatter(mu1_real_res[0], mu1_real_res[1], marker='.', color='blue', alpha=0.7, label='x$|$y')\n",
    "plt.legend(loc='lower right', fontsize=12)\n",
    "plt.title('$p(x)$ vs $p(x|y)$', fontsize=14)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "57dc1ad6",
   "metadata": {},
   "outputs": [],
   "source": [
    "x_1 = np.array([4.5, 5]).reshape(2,1).astype(np.float64)\n",
    "y_1 = A @ x_1 + np.random.multivariate_normal(np.array([0,0]), Nsigma, (1,)).reshape(2,1).astype(np.float64)\n",
    "# y_1 = np.array([[3.5], [6.35]]).astype(np.float64)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "8da31632",
   "metadata": {},
   "outputs": [],
   "source": [
    "iters = 500\n",
    "n_ev = 2\n",
    "c = 1e-5\n",
    "\n",
    "custom_ev = None\n",
    "\n",
    "A_invT = np.linalg.inv(A.T)\n",
    "mmse = mu1_real(y_1, A, sigma1, sigma2, Nsigma, m1, m2)\n",
    "bmmse = np.concatenate([mmse] * n_ev, axis=1)\n",
    "eigvecs = np.random.randn(*bmmse.shape).astype(np.float64)\n",
    "if custom_ev is None:\n",
    "    for i in range(iters):\n",
    "        out = mu1_real(y_1 + eigvecs, A, sigma1, sigma2, Nsigma, m1, m2)\n",
    "        Ab = (out - mmse)\n",
    "        Ab = Ab @ A_invT\n",
    "        if n_ev > 1:\n",
    "            norm_of_Ab = np.linalg.norm(Ab.astype(np.float64), axis=0).astype(np.float64)\n",
    "            eigvecs = Ab / norm_of_Ab  # Complete the power iteration\n",
    "            \n",
    "            # Make sure the evs are orthonormal\n",
    "            Q = np.linalg.qr(eigvecs.astype(np.float64), mode='reduced')[0].astype(np.float64)\n",
    "            eigvecs = Q / np.linalg.norm(Q.astype(np.float64), axis=0).astype(np.float64)\n",
    "        else:\n",
    "            norm_of_Ab = np.linalg.norm(Ab.astype(np.float64).ravel()).astype(np.float64)\n",
    "            eigvecs = Ab / norm_of_Ab # This completes the power iteration\n",
    "        eigvecs *= c\n",
    "    eigvals = (norm_of_Ab / c * noise_sigma2).reshape(n_ev, )\n",
    "    eigvals /= np.linalg.norm(A_invT, ord=2)\n",
    "    eigvecs /= c\n",
    "else:\n",
    "    eigvecs = custom_ev\n",
    "    out = mu1_real(y_1 + eigvecs * c, A, sigma1, sigma2, Nsigma, m1, m2)\n",
    "    Ab = (out - mmse)\n",
    "    Ab = Ab @ A_invT\n",
    "    eigvals = np.linalg.norm(Ab.astype(np.float64), axis=0).astype(np.float64) / c * noise_sigma2\n",
    "    eigvals /= np.linalg.norm(A_invT, ord=2)\n",
    "first_moments = eigvecs.T @ mmse\n",
    "second_moments = eigvals"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "107253db",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "plt.figure(figsize=(6,5))\n",
    "# plt.scatter(test_samples_y[0], test_samples_y[1], marker='.', color='#fe94d0', alpha=0.6, label='samples from $p_y$', s=5)\n",
    "# plt.scatter(test_samples_x[0], test_samples_x[1], marker='.', color='#74add1', alpha=1, label='samples from $p_x$', s=5)\n",
    "[XX, YY] = np.meshgrid(np.linspace(-4,13, 100), np.linspace(-4,13, 100))\n",
    "xs = np.stack([XX.ravel(), YY.ravel()])\n",
    "\n",
    "c = plt.imshow(px_pdf_real(xs, sigma1, sigma2, m1, m2).reshape(XX.shape), cmap='Blues', origin='lower', extent=[-4, 13, -4, 13], interpolation='bilinear')\n",
    "\n",
    "angle = np.arctan2(eigvecs[1,0], eigvecs[0,0]) * 180 / np.pi\n",
    "ellipse = patches.Ellipse((mmse[0,0], mmse[1,0]), 2 * np.sqrt(eigvals[0]), 2 * np.sqrt(eigvals[1]), angle=angle,\n",
    "                          fill=False, alpha=0.7, edgecolor='#053061', label='$\\sqrt{\\lambda}$')\n",
    "plt.gca().add_artist(ellipse)\n",
    "\n",
    "threesig_ellipse = patches.Ellipse((mmse[0,0], mmse[1,0]), 6 * np.sqrt(eigvals[0]), 6 * np.sqrt(eigvals[1]), angle=angle,\n",
    "                          fill=False, alpha=0.7, edgecolor='#053061', linestyle='--', label='$3\\sqrt{\\lambda}$')\n",
    "plt.gca().add_artist(threesig_ellipse)\n",
    "\n",
    "plt.arrow(mmse[0,0], mmse[1,0], eigvecs[0,0] * 3 * np.sqrt(eigvals[0]), eigvecs[1,0] * 3 * np.sqrt(eigvals[0]), head_length=0, color='#d6604d', linewidth=2, label='$v_1$')\n",
    "plt.arrow(mmse[0,0], mmse[1,0], -eigvecs[0,0] * 3 * np.sqrt(eigvals[0]), -eigvecs[1,0] * 3 * np.sqrt(eigvals[0]), head_length=0, color='#d6604d', linewidth=2)\n",
    "if n_ev > 1:\n",
    "    plt.arrow(mmse[0,0], mmse[1,0], eigvecs[0,1] * 3 * np.sqrt(eigvals[1]), eigvecs[1,1] * 3 * np.sqrt(eigvals[1]), head_length=0, color='#f7b068', linewidth=2, label='$v_2$')\n",
    "    plt.arrow(mmse[0,0], mmse[1,0], -eigvecs[0,1] * 3 * np.sqrt(eigvals[1]), -eigvecs[1,1] * 3 * np.sqrt(eigvals[1]), head_length=0, color='#f7b068', linewidth=2)\n",
    "plt.scatter(y_1[0], y_1[1], marker='o', color='red', label='$y$', s=70)\n",
    "plt.scatter(mmse[0], mmse[1], marker='o', color='black', label='$\\mu_1(y)$', s=70)\n",
    "\n",
    "y_up = (mmse + 3 * np.sqrt(eigvals) * eigvecs)[:,0]\n",
    "y_down = (mmse - 3 * np.sqrt(eigvals) * eigvecs)[:, 0]\n",
    "\n",
    "# plt.scatter(y_up[0], y_up[1], marker='+', color='black', label='$\\mu_1(y) +3\\sqrt{\\lambda} v$', s=70)\n",
    "# plt.scatter(y_down[0], y_down[1], marker='*', color='black', label='$\\mu_1(y) -3 \\sqrt{\\lambda} v$', s=70)\n",
    "# plt.gca().axis([test_samples_y.min(), test_samples_y.max(), test_samples_y.min(), test_samples_y.max()])\n",
    "plt.colorbar(c, ax=plt.gca(), label=\"$p_x$\", fraction=0.046, pad=0.04)\n",
    "\n",
    "# plt.colorbar()\n",
    "# plt.clabel('$p_x$')\n",
    "plt.legend(loc='lower right', labelspacing=0.3)\n",
    "plt.tight_layout()\n",
    "ylimmin, ylimmax = plt.gca().get_ylim()\n",
    "xlimmin, xlimmax = plt.gca().get_xlim()\n",
    "os.makedirs('Figures', exist_ok=True)\n",
    "plt.savefig(os.path.join('Figures', 'GMM_Example_theoretical.pdf'), dpi=500, bbox_inches='tight')\n",
    "plt.savefig(os.path.join('Figures', 'GMM_Example_theoretical.png'), dpi=500, bbox_inches='tight')\n",
    "plt.savefig(os.path.join('Figures', 'GMM_Example_theoretical.svg'), dpi=500, bbox_inches='tight')\n",
    "plt.savefig(os.path.join('Figures', 'GMM_Example_theoretical.eps'), dpi=500, bbox_inches='tight')\n",
    "subprocess.call('inkscape Figures/GMM_Example_theoretical.svg --export-type=\"emf\"',shell=True)\n",
    "\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "b34369ea",
   "metadata": {},
   "outputs": [],
   "source": [
    "h=1e-5\n",
    "third_moments = []\n",
    "fourth_moments = []\n",
    "for i in range(n_ev):\n",
    "    first_term = mu1_real(y_1 + eigvecs[:, i].reshape(2,1) * 2 * h, A, sigma1, sigma2, Nsigma, m1, m2)\n",
    "    second_term = mu1_real(y_1 + eigvecs[:, i].reshape(2,1) * h, A, sigma1, sigma2, Nsigma, m1, m2)\n",
    "    third_term = mu1_real(y_1, A, sigma1, sigma2, Nsigma, m1, m2)\n",
    "    fourth_term = mu1_real(y_1 - eigvecs[:, i].reshape(2,1) * h, A, sigma1, sigma2, Nsigma, m1, m2)\n",
    "    deriv_approx = (1/(h**3)) * (first_term - 3 * second_term + 3 * third_term - fourth_term)\n",
    "\n",
    "    fourth_moments.append((noise_sigma2 ** 3) * (eigvecs[:, i] @ deriv_approx)[0] + 3 * (second_moments[i] ** 2))\n",
    "\n",
    "    deriv_approx = (1/(h**2)) * (second_term - 2 * third_term + fourth_term)\n",
    "    third_moments.append((noise_sigma2 ** 2) * (eigvecs[:, i] @ deriv_approx)[0])\n",
    "\n",
    "print(f'vmu1 = {first_moments[:,0]};')\n",
    "print(f'vmu2 = {second_moments};')\n",
    "print(f'vmu3 = {third_moments};')\n",
    "print(f'vmu4 = {fourth_moments};')\n",
    "print(f'noisy_sample = [{y_1[0,0]}; {y_1[1,0]}];')\n",
    "print(f'mmse_sample = [{mmse[0,0]}; {mmse[1,0]}];')\n",
    "print(f'real_sample = [{x_1[0,0]} {x_1[1,0]}];')\n",
    "print(f'evs = {eigvecs};')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "id": "15177d80",
   "metadata": {},
   "outputs": [],
   "source": [
    "# x: sqrt(second_moments), i.e. lambda/eigenvalues of the second moment matrix\n",
    "# y: v^T E(x|y)\n",
    "%notebook inline\n",
    "\n",
    "def poly(xs, coeffs):\n",
    "    deg = len(coeffs) -1\n",
    "    \n",
    "    value = np.zeros_like(xs, dtype=xs.dtype)\n",
    "    for d in range(len(coeffs)):\n",
    "        value += coeffs[d] * (xs ** (deg - d))\n",
    "    return value\n",
    "\n",
    "def d1_dx_poly(xs, coeffs):\n",
    "    deg = len(coeffs) - 1\n",
    "    \n",
    "    value = np.zeros_like(xs, dtype=xs.dtype)\n",
    "    for i in range(deg):\n",
    "        value += (deg - i) * coeffs[i] * (xs ** (deg - 1 - i))\n",
    "    return value\n",
    "\n",
    "def d2_dx_poly(xs, coeffs):\n",
    "    deg = len(coeffs) - 1\n",
    "    \n",
    "    value = np.zeros_like(xs, dtype=xs.dtype)\n",
    "    for i in range(deg - 1):\n",
    "        value += (deg - i) * (deg - 1 - i) * coeffs[i] * (xs ** (deg - 2 - i))\n",
    "    return value\n",
    "    \n",
    "def d3_dx_poly(xs, coeffs):\n",
    "    deg = len(coeffs) - 1\n",
    "    \n",
    "    value = np.zeros_like(xs, dtype=xs.dtype)\n",
    "    for i in range(deg - 2):\n",
    "        value += (deg - i) * (deg - 1 - i) * (deg - 2 - i) * coeffs[i] * (xs ** (deg - 3 - i))\n",
    "    return value\n",
    "\n",
    "\n",
    "deg = 6\n",
    "delta = 30\n",
    "fromto = 0.5\n",
    "third_moments = []\n",
    "fourth_moments = []\n",
    "plt.figure(figsize=(7*n_ev, 4))\n",
    "for i in range(n_ev):\n",
    "    poly_xs = np.linspace(-fromto, fromto,delta) * np.sqrt(second_moments[i])\n",
    "    poly_ys = eigvecs[:, i] @ mu1_real(y_1 + poly_xs * eigvecs[:, i].reshape(2,1),  A, sigma1, sigma2, Nsigma, m1, m2)\n",
    "\n",
    "    coeffs = np.polyfit(poly_xs.astype(np.float64), poly_ys.astype(np.float64), deg=deg)\n",
    "\n",
    "    plt.subplot(1, n_ev, i + 1)\n",
    "    plt.plot(np.linspace(-fromto, fromto,delta), poly_ys, 'k.')\n",
    "    poly_more_xs = np.linspace(-fromto, fromto, delta * 10) * np.sqrt(second_moments[i])\n",
    "    \n",
    "    realf = eigvecs[:, i] @ mu1_real(y_1 + poly_more_xs * eigvecs[:, i].reshape(2,1),  A, sigma1, sigma2, Nsigma, m1, m2)\n",
    "    plt.plot(np.linspace(-fromto, fromto,delta*10), realf, label=\"real\")\n",
    "    plt.plot(np.linspace(-fromto, fromto,delta*10), poly(poly_more_xs, coeffs), label=\"poly\")\n",
    "    plt.legend()\n",
    "    plt.title(f'ev {i+1}')\n",
    "    \n",
    "    d1_dx = noise_sigma2 * d1_dx_poly(np.array([0], dtype=y_1.dtype), coeffs)\n",
    "    print(f'd1_x[0]: {d1_dx[0]}')\n",
    "    d2_dx = d2_dx_poly(np.array([0], dtype=y_1.dtype), coeffs)\n",
    "    d3_dx = d3_dx_poly(np.array([0], dtype=y_1.dtype), coeffs)\n",
    "    third_moments.append((noise_sigma2 ** 2) * (d2_dx)[0])\n",
    "    # fourth_moments.append((noise_sigma2 ** 3) * d3_dx[0] + 3 * (second_moments[i] ** 2))\n",
    "    fourth_moments.append((noise_sigma2 ** 3) * d3_dx[0] + 3 * (d1_dx[0] ** 2))\n",
    "\n",
    "plt.suptitle(f'deg={deg} $N_{{pts}}$={delta}')\n",
    "#     first_term = mu1_real(y_1 + eigvecs[:, i].reshape(2,1) * 2 * h, sigma1, sigma2, Nsigma, m1, m2)\n",
    "#     second_term = mu1_real(y_1 + eigvecs[:, i].reshape(2,1) * h, sigma1, sigma2, Nsigma, m1, m2)\n",
    "#     third_term = mu1_real(y_1, sigma1, sigma2, Nsigma, m1, m2)\n",
    "#     fourth_term = mu1_real(y_1 - eigvecs[:, i].reshape(2,1) * h, sigma1, sigma2, Nsigma, m1, m2)\n",
    "#     deriv_approx = (1/(h**3)) * (first_term - 3 * second_term + 3 * third_term - fourth_term)\n",
    "\n",
    "#     fourth_moments.append((noise_sigma2 ** 3) * (eigvecs[:, i] @ deriv_approx)[0] + 3 * (second_moments[i] ** 2))\n",
    "\n",
    "#     deriv_approx = (1/(h**2)) * (second_term - 2 * third_term + fourth_term)\n",
    "#     third_moments.append((noise_sigma2 ** 2) * (eigvecs[:, i] @ deriv_approx)[0])\n",
    "\n",
    "print(f'vmu1 = {first_moments[:,0]};')\n",
    "print(f'vmu2 = {second_moments};')\n",
    "print(f'vmu3 = {third_moments};')\n",
    "print(f'vmu4 = {fourth_moments};')\n",
    "print(f'noisy_sample = [{y_1[0,0]}; {y_1[1,0]}];')\n",
    "print(f'mmse_sample = [{mmse[0,0]}; {mmse[1,0]}];')\n",
    "print(f'real_sample = [{x_1[0,0]} {x_1[1,0]}];')\n",
    "print(f'evs = {eigvecs};')"
   ]
  }
 ],
 "metadata": {},
 "nbformat": 4,
 "nbformat_minor": 5
}
